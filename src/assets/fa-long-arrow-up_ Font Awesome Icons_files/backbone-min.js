(function (t) {
  const e = typeof self === 'object' && self.self == self && self || typeof global === 'object' && global.global == global && global; if (typeof define === 'function' && define.amd) { define(['underscore', 'jquery', 'exports'], (i, r, n) => { e.Backbone = t(e, n, i, r); }); } else if (typeof exports !== 'undefined') {
    let i = require('underscore'),
      r; try { r = require('jquery'); } catch (n) {}t(e, exports, i, r);
  } else { e.Backbone = t(e, {}, e._, e.jQuery || e.Zepto || e.ender || e.$); }
}((t, e, i, r) => {
  const n = t.Backbone; const s = Array.prototype.slice; e.VERSION = '1.2.2'; e.$ = r; e.noConflict = function () { t.Backbone = n; return this; }; e.emulateHTTP = false; e.emulateJSON = false; const a = function (t, e, r) { switch (t) { case 1: return function () { return i[e](this[r]); }; case 2: return function (t) { return i[e](this[r], t); }; case 3: return function (t, n) { return i[e](this[r], h(t, this), n); }; case 4: return function (t, n, s) { return i[e](this[r], h(t, this), n, s); }; default: return function () { const t = s.call(arguments); t.unshift(this[r]); return i[e](...t); }; } }; const o = function (t, e, r) { i.each(e, (e, n) => { if (i[n])t.prototype[n] = a(e, n, r); }); }; var h = function (t, e) { if (i.isFunction(t)) return t; if (i.isObject(t) && !e._isModel(t)) return u(t); if (i.isString(t)) return function (e) { return e.get(t); }; return t; }; var u = function (t) { const e = i.matches(t); return function (t) { return e(t.attributes); }; }; const l = e.Events = {}; const c = /\s+/; var f = function (t, e, r, n, s) {
    let a = 0,
      o; if (r && typeof r === 'object') { if (n !== void 0 && 'context' in s && s.context === void 0)s.context = n; for (o = i.keys(r); a < o.length; a++) { e = f(t, e, o[a], r[o[a]], s); } } else if (r && c.test(r)) { for (o = r.split(c); a < o.length; a++) { e = t(e, o[a], n, s); } } else { e = t(e, r, n, s); } return e;
  }; l.on = function (t, e, i) { return d(this, t, e, i); }; var d = function (t, e, i, r, n) { t._events = f(v, t._events || {}, e, i, { context: r, ctx: t, listening: n }); if (n) { const s = t._listeners || (t._listeners = {}); s[n.id] = n; } return t; }; l.listenTo = function (t, e, r) {
    if (!t) return this; const n = t._listenId || (t._listenId = i.uniqueId('l')); const s = this._listeningTo || (this._listeningTo = {}); let a = s[n]; if (!a) {
      const o = this._listenId || (this._listenId = i.uniqueId('l')); a = s[n] = {
        obj: t, objId: n, id: o, listeningTo: s, count: 0,
      };
    }d(t, e, r, this, a); return this;
  }; var v = function (t, e, i, r) {
    if (i) {
      const n = t[e] || (t[e] = []); let s = r.context,
        a = r.ctx,
        o = r.listening; if (o)o.count++; n.push({
        callback: i, context: s, ctx: s || a, listening: o,
      });
    } return t;
  }; l.off = function (t, e, i) { if (!this._events) return this; this._events = f(g, this._events, t, e, { context: i, listeners: this._listeners }); return this; }; l.stopListening = function (t, e, r) { const n = this._listeningTo; if (!n) return this; const s = t ? [t._listenId] : i.keys(n); for (let a = 0; a < s.length; a++) { const o = n[s[a]]; if (!o) break; o.obj.off(e, r, this); } if (i.isEmpty(n)) this._listeningTo = void 0; return this; }; var g = function (t, e, r, n) {
    if (!t) return; let s = 0,
      a; let o = n.context,
      h = n.listeners; if (!e && !r && !o) { const u = i.keys(h); for (;s < u.length; s++) { a = h[u[s]]; delete h[a.id]; delete a.listeningTo[a.objId]; } return; } const l = e ? [e] : i.keys(t); for (;s < l.length; s++) { e = l[s]; const c = t[e]; if (!c) break; const f = []; for (let d = 0; d < c.length; d++) { const v = c[d]; if (r && r !== v.callback && r !== v.callback._callback || o && o !== v.context) { f.push(v); } else { a = v.listening; if (a && --a.count === 0) { delete h[a.id]; delete a.listeningTo[a.objId]; } } } if (f.length) { t[e] = f; } else { delete t[e]; } } if (i.size(t)) return t;
  }; l.once = function (t, e, r) { const n = f(p, {}, t, e, i.bind(this.off, this)); return this.on(n, void 0, r); }; l.listenToOnce = function (t, e, r) { const n = f(p, {}, e, r, i.bind(this.stopListening, this, t)); return this.listenTo(t, n); }; var p = function (t, e, r, n) { if (r) { var s = t[e] = i.once(function () { n(e, s); r.apply(this, arguments); }); s._callback = r; } return t; }; l.trigger = function (t) { if (!this._events) return this; const e = Math.max(0, arguments.length - 1); const i = Array(e); for (let r = 0; r < e; r++)i[r] = arguments[r + 1]; f(m, this._events, t, void 0, i); return this; }; var m = function (t, e, i, r) { if (t) { const n = t[e]; let s = t.all; if (n && s)s = s.slice(); if (n)_(n, r); if (s)_(s, [e].concat(r)); } return t; }; var _ = function (t, e) {
    let i,
      r = -1,
      n = t.length,
      s = e[0],
      a = e[1],
      o = e[2]; switch (e.length) { case 0: while (++r < n)(i = t[r]).callback.call(i.ctx); return; case 1: while (++r < n)(i = t[r]).callback.call(i.ctx, s); return; case 2: while (++r < n)(i = t[r]).callback.call(i.ctx, s, a); return; case 3: while (++r < n)(i = t[r]).callback.call(i.ctx, s, a, o); return; default: while (++r < n)(i = t[r]).callback.apply(i.ctx, e); }
  }; l.bind = l.on; l.unbind = l.off; i.extend(e, l); const y = e.Model = function (t, e) { let r = t || {}; e || (e = {}); this.cid = i.uniqueId(this.cidPrefix); this.attributes = {}; if (e.collection) this.collection = e.collection; if (e.parse)r = this.parse(r, e) || {}; r = i.defaults({}, r, i.result(this, 'defaults')); this.set(r, e); this.changed = {}; this.initialize.apply(this, arguments); }; i.extend(y.prototype, l, {
    changed: null, validationError: null, idAttribute: 'id', cidPrefix: 'c', initialize() {}, toJSON(t) { return i.clone(this.attributes); }, sync() { return e.sync.apply(this, arguments); }, get(t) { return this.attributes[t]; }, escape(t) { return i.escape(this.get(t)); }, has(t) { return this.get(t) != null; }, matches(t) { return !!i.iteratee(t, this)(this.attributes); }, set(t, e, r) { if (t == null) return this; let n; if (typeof t === 'object') { n = t; r = e; } else { (n = {})[t] = e; }r || (r = {}); if (!this._validate(n, r)) return false; const s = r.unset; const a = r.silent; const o = []; const h = this._changing; this._changing = true; if (!h) { this._previousAttributes = i.clone(this.attributes); this.changed = {}; } const u = this.attributes; const l = this.changed; const c = this._previousAttributes; for (const f in n) { e = n[f]; if (!i.isEqual(u[f], e))o.push(f); if (!i.isEqual(c[f], e)) { l[f] = e; } else { delete l[f]; }s ? delete u[f] : u[f] = e; } this.id = this.get(this.idAttribute); if (!a) { if (o.length) this._pending = r; for (let d = 0; d < o.length; d++) { this.trigger(`change:${o[d]}`, this, u[o[d]], r); } } if (h) return this; if (!a) { while (this._pending) { r = this._pending; this._pending = false; this.trigger('change', this, r); } } this._pending = false; this._changing = false; return this; }, unset(t, e) { return this.set(t, void 0, i.extend({}, e, { unset: true })); }, clear(t) { const e = {}; for (const r in this.attributes)e[r] = void 0; return this.set(e, i.extend({}, t, { unset: true })); }, hasChanged(t) { if (t == null) return !i.isEmpty(this.changed); return i.has(this.changed, t); }, changedAttributes(t) { if (!t) return this.hasChanged() ? i.clone(this.changed) : false; const e = this._changing ? this._previousAttributes : this.attributes; const r = {}; for (const n in t) { const s = t[n]; if (i.isEqual(e[n], s)) continue; r[n] = s; } return i.size(r) ? r : false; }, previous(t) { if (t == null || !this._previousAttributes) return null; return this._previousAttributes[t]; }, previousAttributes() { return i.clone(this._previousAttributes); }, fetch(t) { t = i.extend({ parse: true }, t); const e = this; const r = t.success; t.success = function (i) { const n = t.parse ? e.parse(i, t) : i; if (!e.set(n, t)) return false; if (r)r.call(t.context, e, i, t); e.trigger('sync', e, i, t); }; z(this, t); return this.sync('read', this, t); }, save(t, e, r) { let n; if (t == null || typeof t === 'object') { n = t; r = e; } else { (n = {})[t] = e; }r = i.extend({ validate: true, parse: true }, r); const s = r.wait; if (n && !s) { if (!this.set(n, r)) return false; } else if (!this._validate(n, r)) return false; const a = this; const o = r.success; const h = this.attributes; r.success = function (t) { a.attributes = h; let e = r.parse ? a.parse(t, r) : t; if (s)e = i.extend({}, n, e); if (e && !a.set(e, r)) return false; if (o)o.call(r.context, a, t, r); a.trigger('sync', a, t, r); }; z(this, r); if (n && s) this.attributes = i.extend({}, h, n); const u = this.isNew() ? 'create' : r.patch ? 'patch' : 'update'; if (u === 'patch' && !r.attrs)r.attrs = n; const l = this.sync(u, this, r); this.attributes = h; return l; }, destroy(t) { t = t ? i.clone(t) : {}; const e = this; const r = t.success; const n = t.wait; const s = function () { e.stopListening(); e.trigger('destroy', e, e.collection, t); }; t.success = function (i) { if (n)s(); if (r)r.call(t.context, e, i, t); if (!e.isNew())e.trigger('sync', e, i, t); }; let a = false; if (this.isNew()) { i.defer(t.success); } else { z(this, t); a = this.sync('delete', this, t); } if (!n)s(); return a; }, url() { const t = i.result(this, 'urlRoot') || i.result(this.collection, 'url') || F(); if (this.isNew()) return t; const e = this.get(this.idAttribute); return t.replace(/[^\/]$/, '$&/') + encodeURIComponent(e); }, parse(t, e) { return t; }, clone() { return new this.constructor(this.attributes); }, isNew() { return !this.has(this.idAttribute); }, isValid(t) { return this._validate({}, i.defaults({ validate: true }, t)); }, _validate(t, e) { if (!e.validate || !this.validate) return true; t = i.extend({}, this.attributes, t); const r = this.validationError = this.validate(t, e) || null; if (!r) return true; this.trigger('invalid', this, r, i.extend(e, { validationError: r })); return false; },
  }); const b = {
    keys: 1, values: 1, pairs: 1, invert: 1, pick: 0, omit: 0, chain: 1, isEmpty: 1,
  }; o(y, b, 'attributes'); const x = e.Collection = function (t, e) { e || (e = {}); if (e.model) this.model = e.model; if (e.comparator !== void 0) this.comparator = e.comparator; this._reset(); this.initialize.apply(this, arguments); if (t) this.reset(t, i.extend({ silent: true }, e)); }; const w = { add: true, remove: true, merge: true }; const E = { add: true, remove: false }; const k = function (t, e, i) { const r = Array(t.length - i); const n = e.length; for (var s = 0; s < r.length; s++)r[s] = t[s + i]; for (s = 0; s < n; s++)t[s + i] = e[s]; for (s = 0; s < r.length; s++)t[s + n + i] = r[s]; }; i.extend(x.prototype, l, {
    model: y, initialize() {}, toJSON(t) { return this.map(e => e.toJSON(t)); }, sync() { return e.sync.apply(this, arguments); }, add(t, e) { return this.set(t, i.extend({ merge: false }, e, E)); }, remove(t, e) { e = i.extend({}, e); const r = !i.isArray(t); t = r ? [t] : i.clone(t); const n = this._removeModels(t, e); if (!e.silent && n) this.trigger('update', this, e); return r ? n[0] : n; }, set(t, e) { if (t == null) return; e = i.defaults({}, e, w); if (e.parse && !this._isModel(t))t = this.parse(t, e); const r = !i.isArray(t); t = r ? [t] : t.slice(); let n = e.at; if (n != null)n = +n; if (n < 0)n += this.length + 1; const s = []; const a = []; const o = []; const h = {}; const u = e.add; const l = e.merge; const c = e.remove; let f = false; const d = this.comparator && n == null && e.sort !== false; const v = i.isString(this.comparator) ? this.comparator : null; let g; for (var p = 0; p < t.length; p++) { g = t[p]; const m = this.get(g); if (m) { if (l && g !== m) { let _ = this._isModel(g) ? g.attributes : g; if (e.parse)_ = m.parse(_, e); m.set(_, e); if (d && !f)f = m.hasChanged(v); } if (!h[m.cid]) { h[m.cid] = true; s.push(m); }t[p] = m; } else if (u) { g = t[p] = this._prepareModel(g, e); if (g) { a.push(g); this._addReference(g, e); h[g.cid] = true; s.push(g); } } } if (c) { for (p = 0; p < this.length; p++) { g = this.models[p]; if (!h[g.cid])o.push(g); } if (o.length) this._removeModels(o, e); } let y = false; const b = !d && u && c; if (s.length && b) { y = this.length != s.length || i.some(this.models, (t, e) => t !== s[e]); this.models.length = 0; k(this.models, s, 0); this.length = this.models.length; } else if (a.length) { if (d)f = true; k(this.models, a, n == null ? this.length : n); this.length = this.models.length; } if (f) this.sort({ silent: true }); if (!e.silent) { for (p = 0; p < a.length; p++) { if (n != null)e.index = n + p; g = a[p]; g.trigger('add', g, this, e); } if (f || y) this.trigger('sort', this, e); if (a.length || o.length) this.trigger('update', this, e); } return r ? t[0] : t; }, reset(t, e) { e = e ? i.clone(e) : {}; for (let r = 0; r < this.models.length; r++) { this._removeReference(this.models[r], e); }e.previousModels = this.models; this._reset(); t = this.add(t, i.extend({ silent: true }, e)); if (!e.silent) this.trigger('reset', this, e); return t; }, push(t, e) { return this.add(t, i.extend({ at: this.length }, e)); }, pop(t) { const e = this.at(this.length - 1); return this.remove(e, t); }, unshift(t, e) { return this.add(t, i.extend({ at: 0 }, e)); }, shift(t) { const e = this.at(0); return this.remove(e, t); }, slice() { return s.apply(this.models, arguments); }, get(t) { if (t == null) return void 0; const e = this.modelId(this._isModel(t) ? t.attributes : t); return this._byId[t] || this._byId[e] || this._byId[t.cid]; }, at(t) { if (t < 0)t += this.length; return this.models[t]; }, where(t, e) { return this[e ? 'find' : 'filter'](t); }, findWhere(t) { return this.where(t, true); }, sort(t) { let e = this.comparator; if (!e) throw new Error('Cannot sort a set without a comparator'); t || (t = {}); const r = e.length; if (i.isFunction(e))e = i.bind(e, this); if (r === 1 || i.isString(e)) { this.models = this.sortBy(e); } else { this.models.sort(e); } if (!t.silent) this.trigger('sort', this, t); return this; }, pluck(t) { return i.invoke(this.models, 'get', t); }, fetch(t) { t = i.extend({ parse: true }, t); const e = t.success; const r = this; t.success = function (i) { const n = t.reset ? 'reset' : 'set'; r[n](i, t); if (e)e.call(t.context, r, i, t); r.trigger('sync', r, i, t); }; z(this, t); return this.sync('read', this, t); }, create(t, e) { e = e ? i.clone(e) : {}; const r = e.wait; t = this._prepareModel(t, e); if (!t) return false; if (!r) this.add(t, e); const n = this; const s = e.success; e.success = function (t, e, i) { if (r)n.add(t, i); if (s)s.call(i.context, t, e, i); }; t.save(null, e); return t; }, parse(t, e) { return t; }, clone() { return new this.constructor(this.models, { model: this.model, comparator: this.comparator }); }, modelId(t) { return t[this.model.prototype.idAttribute || 'id']; }, _reset() { this.length = 0; this.models = []; this._byId = {}; }, _prepareModel(t, e) { if (this._isModel(t)) { if (!t.collection)t.collection = this; return t; }e = e ? i.clone(e) : {}; e.collection = this; const r = new this.model(t, e); if (!r.validationError) return r; this.trigger('invalid', this, r.validationError, e); return false; }, _removeModels(t, e) { const i = []; for (let r = 0; r < t.length; r++) { const n = this.get(t[r]); if (!n) continue; const s = this.indexOf(n); this.models.splice(s, 1); this.length--; if (!e.silent) { e.index = s; n.trigger('remove', n, this, e); }i.push(n); this._removeReference(n, e); } return i.length ? i : false; }, _isModel(t) { return t instanceof y; }, _addReference(t, e) { this._byId[t.cid] = t; const i = this.modelId(t.attributes); if (i != null) this._byId[i] = t; t.on('all', this._onModelEvent, this); }, _removeReference(t, e) { delete this._byId[t.cid]; const i = this.modelId(t.attributes); if (i != null) delete this._byId[i]; if (this === t.collection) delete t.collection; t.off('all', this._onModelEvent, this); }, _onModelEvent(t, e, i, r) { if ((t === 'add' || t === 'remove') && i !== this) return; if (t === 'destroy') this.remove(e, r); if (t === 'change') { const n = this.modelId(e.previousAttributes()); const s = this.modelId(e.attributes); if (n !== s) { if (n != null) delete this._byId[n]; if (s != null) this._byId[s] = e; } } this.trigger.apply(this, arguments); },
  }); const S = {
    forEach: 3, each: 3, map: 3, collect: 3, reduce: 4, foldl: 4, inject: 4, reduceRight: 4, foldr: 4, find: 3, detect: 3, filter: 3, select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3, contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3, head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3, without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3, isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3, sortBy: 3, indexBy: 3,
  }; o(x, S, 'models'); const I = e.View = function (t) { this.cid = i.uniqueId('view'); i.extend(this, i.pick(t, P)); this._ensureElement(); this.initialize.apply(this, arguments); }; const T = /^(\S+)\s*(.*)$/; var P = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events']; i.extend(I.prototype, l, {
    tagName: 'div', $(t) { return this.$el.find(t); }, initialize() {}, render() { return this; }, remove() { this._removeElement(); this.stopListening(); return this; }, _removeElement() { this.$el.remove(); }, setElement(t) { this.undelegateEvents(); this._setElement(t); this.delegateEvents(); return this; }, _setElement(t) { this.$el = t instanceof e.$ ? t : e.$(t); this.el = this.$el[0]; }, delegateEvents(t) { t || (t = i.result(this, 'events')); if (!t) return this; this.undelegateEvents(); for (const e in t) { let r = t[e]; if (!i.isFunction(r))r = this[r]; if (!r) continue; const n = e.match(T); this.delegate(n[1], n[2], i.bind(r, this)); } return this; }, delegate(t, e, i) { this.$el.on(`${t}.delegateEvents${this.cid}`, e, i); return this; }, undelegateEvents() { if (this.$el) this.$el.off(`.delegateEvents${this.cid}`); return this; }, undelegate(t, e, i) { this.$el.off(`${t}.delegateEvents${this.cid}`, e, i); return this; }, _createElement(t) { return document.createElement(t); }, _ensureElement() { if (!this.el) { const t = i.extend({}, i.result(this, 'attributes')); if (this.id)t.id = i.result(this, 'id'); if (this.className)t.class = i.result(this, 'className'); this.setElement(this._createElement(i.result(this, 'tagName'))); this._setAttributes(t); } else { this.setElement(i.result(this, 'el')); } }, _setAttributes(t) { this.$el.attr(t); },
  }); e.sync = function (t, r, n) { const s = H[t]; i.defaults(n || (n = {}), { emulateHTTP: e.emulateHTTP, emulateJSON: e.emulateJSON }); const a = { type: s, dataType: 'json' }; if (!n.url) { a.url = i.result(r, 'url') || F(); } if (n.data == null && r && (t === 'create' || t === 'update' || t === 'patch')) { a.contentType = 'application/json'; a.data = JSON.stringify(n.attrs || r.toJSON(n)); } if (n.emulateJSON) { a.contentType = 'application/x-www-form-urlencoded'; a.data = a.data ? { model: a.data } : {}; } if (n.emulateHTTP && (s === 'PUT' || s === 'DELETE' || s === 'PATCH')) { a.type = 'POST'; if (n.emulateJSON)a.data._method = s; const o = n.beforeSend; n.beforeSend = function (t) { t.setRequestHeader('X-HTTP-Method-Override', s); if (o) return o.apply(this, arguments); }; } if (a.type !== 'GET' && !n.emulateJSON) { a.processData = false; } const h = n.error; n.error = function (t, e, i) { n.textStatus = e; n.errorThrown = i; if (h)h.call(n.context, t, e, i); }; const u = n.xhr = e.ajax(i.extend(a, n)); r.trigger('request', r, u, n); return u; }; var H = {
    create: 'POST', update: 'PUT', patch: 'PATCH', delete: 'DELETE', read: 'GET',
  }; e.ajax = function () { return e.$.ajax.apply(e.$, arguments); }; const $ = e.Router = function (t) { t || (t = {}); if (t.routes) this.routes = t.routes; this._bindRoutes(); this.initialize.apply(this, arguments); }; const A = /\((.*?)\)/g; const C = /(\(\?)?:\w+/g; const R = /\*\w+/g; const j = /[\-{}\[\]+?.,\\\^$|#\s]/g; i.extend($.prototype, l, {
    initialize() {},
    route(t, r, n) { if (!i.isRegExp(t))t = this._routeToRegExp(t); if (i.isFunction(r)) { n = r; r = ''; } if (!n)n = this[r]; const s = this; e.history.route(t, (i) => { const a = s._extractParameters(t, i); if (s.execute(n, a, r) !== false) { s.trigger(...[`route:${r}`].concat(a)); s.trigger('route', r, a); e.history.trigger('route', s, r, a); } }); return this; },
    execute(t, e, i) { if (t)t.apply(this, e); },
    navigate(t, i) { e.history.navigate(t, i); return this; },
    _bindRoutes() {
      if (!this.routes) return; this.routes = i.result(this, 'routes'); let t,
        e = i.keys(this.routes); while ((t = e.pop()) != null) { this.route(t, this.routes[t]); }
    },
    _routeToRegExp(t) { t = t.replace(j, '\\$&').replace(A, '(?:$1)?').replace(C, (t, e) => (e ? t : '([^/?]+)')).replace(R, '([^?]*?)'); return new RegExp(`^${t}(?:\\?([\\s\\S]*))?$`); },
    _extractParameters(t, e) { const r = t.exec(e).slice(1); return i.map(r, (t, e) => { if (e === r.length - 1) return t || null; return t ? decodeURIComponent(t) : null; }); },
  }); const N = e.History = function () { this.handlers = []; this.checkUrl = i.bind(this.checkUrl, this); if (typeof window !== 'undefined') { this.location = window.location; this.history = window.history; } }; const M = /^[#\/]|\s+$/g; const O = /^\/+|\/+$/g; const U = /#.*$/; N.started = false; i.extend(N.prototype, l, {
    interval: 50, atRoot() { const t = this.location.pathname.replace(/[^\/]$/, '$&/'); return t === this.root && !this.getSearch(); }, matchRoot() { const t = this.decodeFragment(this.location.pathname); const e = `${t.slice(0, this.root.length - 1)}/`; return e === this.root; }, decodeFragment(t) { return decodeURI(t.replace(/%25/g, '%2525')); }, getSearch() { const t = this.location.href.replace(/#.*/, '').match(/\?.+/); return t ? t[0] : ''; }, getHash(t) { const e = (t || this).location.href.match(/#(.*)$/); return e ? e[1] : ''; }, getPath() { const t = this.decodeFragment(this.location.pathname + this.getSearch()).slice(this.root.length - 1); return t.charAt(0) === '/' ? t.slice(1) : t; }, getFragment(t) { if (t == null) { if (this._usePushState || !this._wantsHashChange) { t = this.getPath(); } else { t = this.getHash(); } } return t.replace(M, ''); }, start(t) { if (N.started) throw new Error('Backbone.history has already been started'); N.started = true; this.options = i.extend({ root: '/' }, this.options, t); this.root = this.options.root; this._wantsHashChange = this.options.hashChange !== false; this._hasHashChange = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7); this._useHashChange = this._wantsHashChange && this._hasHashChange; this._wantsPushState = !!this.options.pushState; this._hasPushState = !!(this.history && this.history.pushState); this._usePushState = this._wantsPushState && this._hasPushState; this.fragment = this.getFragment(); this.root = (`/${this.root}/`).replace(O, '/'); if (this._wantsHashChange && this._wantsPushState) { if (!this._hasPushState && !this.atRoot()) { const e = this.root.slice(0, -1) || '/'; this.location.replace(`${e}#${this.getPath()}`); return true; } else if (this._hasPushState && this.atRoot()) { this.navigate(this.getHash(), { replace: true }); } } if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) { this.iframe = document.createElement('iframe'); this.iframe.src = 'javascript:0'; this.iframe.style.display = 'none'; this.iframe.tabIndex = -1; const r = document.body; const n = r.insertBefore(this.iframe, r.firstChild).contentWindow; n.document.open(); n.document.close(); n.location.hash = `#${this.fragment}`; } const s = window.addEventListener || function (t, e) { return attachEvent(`on${t}`, e); }; if (this._usePushState) { s('popstate', this.checkUrl, false); } else if (this._useHashChange && !this.iframe) { s('hashchange', this.checkUrl, false); } else if (this._wantsHashChange) { this._checkUrlInterval = setInterval(this.checkUrl, this.interval); } if (!this.options.silent) return this.loadUrl(); }, stop() { const t = window.removeEventListener || function (t, e) { return detachEvent(`on${t}`, e); }; if (this._usePushState) { t('popstate', this.checkUrl, false); } else if (this._useHashChange && !this.iframe) { t('hashchange', this.checkUrl, false); } if (this.iframe) { document.body.removeChild(this.iframe); this.iframe = null; } if (this._checkUrlInterval)clearInterval(this._checkUrlInterval); N.started = false; }, route(t, e) { this.handlers.unshift({ route: t, callback: e }); }, checkUrl(t) { let e = this.getFragment(); if (e === this.fragment && this.iframe) { e = this.getHash(this.iframe.contentWindow); } if (e === this.fragment) return false; if (this.iframe) this.navigate(e); this.loadUrl(); }, loadUrl(t) { if (!this.matchRoot()) return false; t = this.fragment = this.getFragment(t); return i.some(this.handlers, (e) => { if (e.route.test(t)) { e.callback(t); return true; } }); }, navigate(t, e) { if (!N.started) return false; if (!e || e === true)e = { trigger: !!e }; t = this.getFragment(t || ''); let i = this.root; if (t === '' || t.charAt(0) === '?') { i = i.slice(0, -1) || '/'; } const r = i + t; t = this.decodeFragment(t.replace(U, '')); if (this.fragment === t) return; this.fragment = t; if (this._usePushState) { this.history[e.replace ? 'replaceState' : 'pushState']({}, document.title, r); } else if (this._wantsHashChange) { this._updateHash(this.location, t, e.replace); if (this.iframe && t !== this.getHash(this.iframe.contentWindow)) { const n = this.iframe.contentWindow; if (!e.replace) { n.document.open(); n.document.close(); } this._updateHash(n.location, t, e.replace); } } else { return this.location.assign(r); } if (e.trigger) return this.loadUrl(t); }, _updateHash(t, e, i) { if (i) { const r = t.href.replace(/(javascript:|#).*$/, ''); t.replace(`${r}#${e}`); } else { t.hash = `#${e}`; } },
  }); e.history = new N(); const q = function (t, e) { const r = this; let n; if (t && i.has(t, 'constructor')) { n = t.constructor; } else { n = function () { return r.apply(this, arguments); }; }i.extend(n, r, e); const s = function () { this.constructor = n; }; s.prototype = r.prototype; n.prototype = new s(); if (t)i.extend(n.prototype, t); n.__super__ = r.prototype; return n; }; y.extend = x.extend = $.extend = I.extend = N.extend = q; var F = function () { throw new Error('A "url" property or function must be specified'); }; var z = function (t, e) { const i = e.error; e.error = function (r) { if (i)i.call(e.context, t, r, e); t.trigger('error', t, r, e); }; }; return e;
}));
// # sourceMappingURL=backbone-min.map
